


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Actor引用，路径和地址 &mdash; Akka文档</title>
    <link rel="stylesheet" href="../_static/style.css" tppabs="http://www.gtan.com/akka_doc/_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" tppabs="http://www.gtan.com/akka_doc/_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" tppabs="http://www.gtan.com/akka_doc/_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" tppabs="http://www.gtan.com/akka_doc/_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" tppabs="http://www.gtan.com/akka_doc/_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="../../../fonts.googleapis.com/css-family=Exo-300,400,600,700.css" tppabs="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js" tppabs="http://www.gtan.com/akka_doc/_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js" tppabs="http://www.gtan.com/akka_doc/_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js" tppabs="http://www.gtan.com/akka_doc/_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js" tppabs="http://www.gtan.com/akka_doc/_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js" tppabs="http://www.gtan.com/akka_doc/_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js" tppabs="http://www.gtan.com/akka_doc/_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js" tppabs="http://www.gtan.com/akka_doc/_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js" tppabs="http://www.gtan.com/akka_doc/_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js" tppabs="http://www.gtan.com/akka_doc/_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js" tppabs="http://www.gtan.com/akka_doc/_static/contentsFix.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="General" href="index.html" />
    <link rel="next" title="Location Transparency" href="remoting.html" />
    <link rel="prev" title="Supervision and Monitoring" href="supervision.html" /> 
  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="javascript:if(confirm('http://akka.io/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/'" tppabs="http://akka.io/"><img src="../_static/logo-small.png" tppabs="http://www.gtan.com/akka_doc/_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="javascript:if(confirm('http://www.gtan.com/welfare04.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.gtan.com/welfare04.html'" tppabs="http://www.gtan.com/welfare04.html">返回广谈公益</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Actor引用，路径和地址</div><div class="pdf-link"><a href="javascript:if(confirm('http://www.gtan.com/akka_doc/Akka.pdf  \n\nļ޷ Teleport Ultra , Ϊ ļδҵ  \n\nڷϴ?'))window.location='http://www.gtan.com/akka_doc/Akka.pdf'" tppabs="http://www.gtan.com/akka_doc/Akka.pdf"><img src="../_static/pdf-icon.png" tppabs="http://www.gtan.com/akka_doc/_static/pdf-icon.png" style="height: 40px;" /></a></div></div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="remoting.html" tppabs="http://www.gtan.com/akka_doc/general/remoting.html">位置透明性</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html" tppabs="http://www.gtan.com/akka_doc/index.html">目录</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="supervision.html" tppabs="http://www.gtan.com/akka_doc/general/supervision.html">监管与监控</a> <span class="divider">|</span>
              </li>
              <li>
                版本 2.0
              </li>
            </ul>         
          </div>
        </div>
        <div class="row">
          <div class="span9">
            
  <div class="section" id="actor-references-paths-and-addresses">
<span id="addressing"></span><h1>Actor引用，路径和地址</h1>
<p>本节描述actor如何鉴别身份，在一个可能分布式的actor系统中如何定位。这与 <a class="reference internal" href="actor-systems.html#actor-systems" tppabs="http://www.gtan.com/akka_doc/general/actor-systems.html#actor-systems"><em>Actor系统</em></a> 的核心概念有关：固有的树形监管结构和在跨多个网络节点的actor之间进行透明通讯。</p>
<img alt="../_images/ActorPath.png" src="../_images/ActorPath.png" tppabs="http://www.gtan.com/akka_doc/_images/ActorPath.png" />
<p>以上图片显示了actor系统中最重要的实体，请继续阅读了解详情。</p>
<div class="section" id="what-is-an-actor-reference">
<h2>Actor引用是什么？</h2>
<p>Actor引用是 <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> 的子类，它的最重要功能是支持向它所代表的actor发送消息。每个actor通过<tt class="xref py py-meth docutils literal"><span class="pre">self</span></tt>来访问它的标准（本地）引用，在发送给其它actor的消息中也缺省包含这个引用。反过来，在消息处理过程中，actor可以通过<tt class="xref py py-meth docutils literal"><span class="pre">sender</span></tt>来访问到当前消息的发送者的引用。</p>
<p>根据actor系统的配置，支持几种不同的actor引用：</p>
<ul class="simple">
<li>纯本地引用使用在配置为不使用网络功能的actor系统中。这些actor引用不能在保持其功能的条件下从网络连接上向外传输。</li>
<li>支持远程调用的本地引用使用在支持同一个jvm中actor引用之间的网络功能的actor系统中。为了在发送到其它网络节点后被识别，这些引用包含了协议和远程地址信息。</li>
<li>本地actor引用有一个子类是用在路由（routers， i.e. mixin 了 <tt class="xref py py-class docutils literal"><span class="pre">Router</span></tt> trait的actor）. 它的逻辑结构与之前的本地引用是一样的，但是向它们发送的消息会被直接重定向到它的子actor。</li>
<li>远程actor引用代表可以通过远程通讯访问的actor，i.e. 从别的jvm向他们发送消息时，Akka会透明地对消息进行序列化。</li>
<li>有几种特殊的actor引用类型，在实际用途中比较类似本地actor引用：<ul>
<li><tt class="xref py py-class docutils literal"><span class="pre">PromiseActorRef</span></tt> 表示一个<tt class="xref py py-meth docutils literal"><span class="pre">Promise</span></tt>，作用是从一个actor返回的响应来完成，它是由 <tt class="xref py py-meth docutils literal"><span class="pre">ActorRef.ask</span></tt> 调用来创建的 </li>
<li><tt class="xref py py-class docutils literal"><span class="pre">DeadLetterActorRef</span></tt> DeadLetterActorRef是死信服务的缺省实现，所有接收方被关闭或不存在的消息都在此被重新路由。</li>
<li><tt class="xref py py-class docutils literal"><span class="pre">EmptyLocalActorRef</span></tt> 是查找一个不存在的本地actor路径时返回的：它相当于<tt class="xref py py-class docutils literal"><span class="pre">DeadLetterActorRef</span></tt>，但是它保有其路径因此可以在网络上发送，以及与其它相同路径的存活的actor引用进行比较，其中一些存活的actor引用可能在该actor消失之前得到了。
</li>
</ul>
</li>
<li>然后有一些内部实现，你可能永远不会用上：<ul>
<li>有一个actor引用并不表示任何actor，只是作为根actor的伪监管者存在，我们称它为“时空气泡穿梭者”。</li>
<li>在actor创建设施启动之前运行的第一个日志服务是一个伪actor引用，它接收日志事件并直接显示到标准输出上；它就是 <tt class="xref py py-class docutils literal"><span class="pre">Logging.StandardOutLogger</span></tt>。</li>
</ul>
</li>
<li><strong>(未来扩展)</strong> Cluster actor references represent clustered actor
services which may be replicated, migrated or load-balanced across multiple
cluster nodes. As such they are virtual names which the cluster service
translates into local or remote actor references as appropriate.</li>
</ul>
</div>
<div class="section" id="what-is-an-actor-path">
<h2>Actor路径是什么?</h2>
<p>由于actor是以一种严格的树形结构样式来创建的，沿着子actor到父actor的监管链一直到actor系统的根存在一条唯一的actor名字序列。这个序列可以类比成文件系统中的文件路径，所以我们称它为“路径”。就象在一些真正的文件系统中一样，也存在所谓的“符号链接”，i.e. 一个actor可能通过不同的路径访问到，除了原始路径外，其它的路径都包含到actor实际的监管祖先链的转换方法。这些特性将在下面的内容中介绍。</p>
<p>一个actor路径包含一个标识该actor系统的锚点，之后是各路径元素连接起来，从根到指定的actor；路径元素是路径经过的actor的名字，以"/"分隔。</p>
<div class="section" id="actor-path-anchors">
<h3>Actor路径锚点</h3>
<p>每一条actor路径都有一个地址组件，描述如何访问到actor的协议和位置，之后是从根到actor所经过的树节点上actor的名字。例如：</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="s">&quot;akka://my-system/user/service-a/worker1&quot;</span>               <span class="c1">// 纯本地</span>
<span class="s">&quot;akka://my-system@serv.example.com:5678/user/service-b&quot;</span> <span class="c1">// 本地或远程</span>
<span class="s">&quot;cluster://my-cluster/service-c&quot;</span>                       <span class="c1">// 集群 (未来扩展)</span>
</pre></div>
</div>
<p>在这里, <tt class="docutils literal"><span class="pre">akka</span></tt> 是2.0版本中缺省的远程协议，其它的协议都是可插拔的。对主机和端口的理解（i.e. 上例中的<tt class="docutils literal"><span class="pre">serv.example.com:5678</span></tt>）决定于所使用的传输机制，</p>
</div>
<div class="section" id="logical-actor-paths">
<h3>逻辑Actor路径</h3>
<p>顺着actor的父监管链一直到根的唯一路径被称为逻辑actor路径。这个路径与actor的创建祖先完全吻合，所以当actor系统的远程调用配置（和配置中路径的地址部分）设置好后它就是完全确定的了。</p>
</div>
<div class="section" id="physical-actor-paths">
<h3>物理Actor路径</h3>
<p>逻辑Actor路径描述一个actor系统内部的功能位置，而基于配置的远程部署意味着一个actor可能在另外一台网络主机上被创建，i.e.在另一个actor系统中。在这种情况下，从根穿过actor路径肯定要访问网络，这是一个昂贵的操作。因此，每一个actor同时还有一条物理路径，从实际的actor对象所在的actor系统的根开始的。跟其它actor通信时使用物理路径作为发送方引用能够让接收方直接回复到这个actor上，将路由延迟降到最小。</p>
<p>一个重要的方面是物理路径决不会跨多个actor系统或跨虚拟机。这意味着一个actor的逻辑路径（监管树）和物理路径（actor部署）可能会分叉，如果它的祖先被远程监管了。</p>
</div>
<div class="section" id="virtual-actor-paths-future-extension">
<h3>虚拟Actor路径 <strong>(未来扩展)</strong></h3>
<p>In order to be able to replicate and migrate actors across a cluster of Akka
nodes, another level of indirection has to be introduced. The cluster component
therefore provides a translation from virtual paths to physical paths which may
change in reaction to node failures, cluster rebalancing, etc.</p>
<p><em>This area is still under active development, expect updates in this section
for the 2.1 release.</em></p>
</div>
</div>
<div class="section" id="how-are-actor-references-obtained">
<h2>如何获得Actor引用？</h2>
<p>关于actor引用的获取方法分为两类：通过创建actor或者通过对actor的拜访查找。后一种功能又分两种：通过具体的actor路径来创建actor引用，和查询逻辑actor树。</p>
<p><em>虽然本地actor引用和远程actor引用的路径按下面提到的相同的方式工作，但真实的集群actor引用和路径的语义——虽然很相似——可能在某些方面存在不同，这与路径的虚拟性质有关。在2.1版 中会更新。</em></p>
<div class="section" id="creating-actors">
<h3>创建Actor</h3>
<p>一个actor系统通常是在根actor上使用<tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.actorOf</span></tt>创建actor，然后使用<tt class="xref py py-meth docutils literal"><span class="pre">ActorContext.actorOf</span></tt>从创建出的actor中生出actor树来启动的。这些方法返回指向新创建的actor的引用。每个actor都拥有到它的父亲，它自己和它的子actor的引用。这些引用可以与消息一直发送给别的actor，以便接收方直接回复。</p>
</div>
<div class="section" id="looking-up-actors-by-concrete-path">
<h3>通过具体的路径来查找actor</h3>
<p>另一种查找actor引用的途径是使用<tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.actorFor</span></tt>方法，它会返回一个（未验证的）本地、远程或集群actor引用。向这个引用发送消息或试图观察它的存活状态会在actor系统树中从根开始一层一层从父向子actor发送消息，直到消息到达目标或是出现某种失败，i.e. 路径中的某一个actor名字不存在（在实际中这个过程会使用缓存来优化，但相较使用物理actor路径来说仍然增加了开销，因为物理路径能够从actor的响应消息中的发送方引用中获得），这个消息传递过程旧由Akka自动完成的，对客户端代码不可见。</p>
<div class="section" id="absolute-vs-relative-paths">
<h4>绝对路径 vs 相对路径</h4>
<p>除了<tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.actorFor</span></tt>还有一个<tt class="xref py py-meth docutils literal"><span class="pre">ActorContext.actorFor</span></tt>，这是在任何一个actor实例中可以用<tt class="docutils literal"><span class="pre">context.actorFor</span></tt>访问的。它所返回的actor引用与<tt class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></tt>的返回值非常类似，但它的路径查找是从当前actor开始的，而不是从actor树的根开始。可以用 <tt class="docutils literal"><span class="pre">&quot;..&quot;</span></tt> 路径来访问父actor. 例如，你可以向一个兄弟发送消息：</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">actorFor</span><span class="o">(</span><span class="s">&quot;../brother&quot;</span><span class="o">)</span> <span class="o">!</span> <span class="n">msg</span>
</pre></div>
</div>
<p>当然绝对路径也可以在 <cite>context</cite> 中使用，i.e.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">actorFor</span><span class="o">(</span><span class="s">&quot;/user/serviceA&quot;</span><span class="o">)</span> <span class="o">!</span> <span class="n">msg</span>
</pre></div>
</div>
<p>也能正确运行。</p>
</div>
</div>
<div class="section" id="querying-the-logical-actor-hierarchy">
<h3>查询逻辑Actor树</h3>
<p>由于actor系统是一个类似文件系统的树形结构，对actor的匹配与unix shell中支持的一样：你可以将路径（中的一部分）用通配符(<cite>«*»</cite> 和 <cite>«?»</cite>)替换来组成对0个或多个实际actor的匹配。由于匹配的结果不是一个单一的actor引用，它拥有一个不同的类型<tt class="xref py py-class docutils literal"><span class="pre">ActorSelection</span></tt>，这个类型不完全支持<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>的所有操作。同样，路径选择也可以用<tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.actorSelection</span></tt>或<tt class="xref py py-meth docutils literal"><span class="pre">ActorContext.actorSelection</span></tt>两种方式来获得，并且支持发送消息：</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;../*&quot;</span><span class="o">)</span> <span class="o">!</span> <span class="n">msg</span>
</pre></div>
</div>
<p>会将<cite>msg</cite>发送给包括当前actor在内的所有兄弟。对于用 <cite>actorFor</cite> 获取的actor引用，为了进行消息的发送，会对监管树进行遍历。由于在消息到达其接收者的过程中与查询条件匹配的actor集合会发生变化，要监视查询的实时变化是不可能的。如果要做这件事情，通过发送一个请求，收集所有的响应来解决不确定性，提取所有的发送方引用，然后监视所有发现的具体actor。这种处理actor选择的方式会在未来的版本中进行改进。</p>
</div>
<div class="section" id="summary-actorof-vs-actorfor">
<span id="actorof-vs-actorfor"></span><h3>总结: <tt class="docutils literal"><span class="pre">actorOf</span></tt> vs. <tt class="docutils literal"><span class="pre">actorFor</span></tt></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>以上部分所描述的细节可以简要地总结和记忆成：</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">actorOf</span></tt> 永远都只会创建一个新的actor，这个新的actor是actorOf所调用上下文（可以是actor系统中的任意一个actor）的直接子actor</li>
<li><tt class="docutils literal"><span class="pre">actorFor</span></tt> 永远都只是查找到一个已存在的actor，不会创建新的actor。</li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-interplay-with-remote-deployment">
<h2>与远程部署之间的互操作</h2>
<p>当一个actor创建一个子actor，actor系统的部署者会决定新的actor是在同一个jvm中或是在其它的节点上。如果是后者，actor的创建会通过网络连接来到另一个jvm中进行，结果是新的actor会进入另一个actor系统。远程系统会将新的actor放在一个专为这种场景所保留的特殊路径下。新的actor的监管者会是一个远程actor引用（代表会触发创建动作的actor）。这时，<tt class="xref py py-meth docutils literal"><span class="pre">context.parent</span></tt>（监管者引用）和<tt class="xref py py-meth docutils literal"><span class="pre">context.path.parent</span></tt>（actor路径上的父actor）表示的actor是不同的。但是在其监管者中查找这个actor的名称能够在远程节点上找到它，保持其逻辑结构，e.g. 当向另外一个未确定(unresolved)的actor引用发送消息时。</p>
<img alt="../_images/RemoteDeployment.png" src="../_images/RemoteDeployment.png" tppabs="http://www.gtan.com/akka_doc/_images/RemoteDeployment.png" />
</div>
<div class="section" id="the-interplay-with-clustering-future-extension">
<h2>与集群的互操作 <strong>(未来扩展)</strong></h2>
<p><em>本部分会变化!</em></p>
<p>When creating a scaled-out actor subtree, a cluster name is created for a
routed actor reference, where sending to this reference will send to one (or
more) of the actual actors created in the cluster. In order for those actors to
be able to query other actors while processing their messages, their sender
reference must be unique for each of the replicas, which means that physical
paths will be used as <tt class="docutils literal"><span class="pre">self</span></tt> references for these instances. In the case
of replication for achieving fault-tolerance the opposite is required: the
<tt class="docutils literal"><span class="pre">self</span></tt> reference will be a virtual (cluster) path so that in case of
migration or fail-over communication is resumed with the fresh instance.</p>
</div>
<div class="section" id="what-is-the-address-part-used-for">
<h2>路径中的地址部分用来做什么？</h2>
<p>在网络上传送actor引用时，是用它的路径来表示这个actor的。所以，它的路径必须包括能够用来向它所代表的actor发送消息的完整的信息。这一点是通过在路径字符串的地址部分包括协议、主机名和端口来做到的。当actor系统从远程节点接收到一个actor路径，会检查它的地址部分是否与自己的地址相同，如果相同，那么会将这条路径解析为本地actor引用，否则解析为一个远程actor引用。</p>
</div>
<div class="section" id="special-paths-used-by-akka">
<h2>Akka使用的特殊路径</h2>
<p>在路径树的根上是根监管者，所有的的actor都可以从通过它找到。在第二个层次上是以下这些：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;/user&quot;</span></tt> 是所有由用户创建的顶级actor的监管者，用 <tt class="xref py py-meth docutils literal"><span class="pre">ActorSystem.actorOf</span></tt> 创建的actor在其下一个层次 are found at the next level.</li>
<li><tt class="docutils literal"><span class="pre">&quot;/system&quot;</span></tt> 是所有由系统创建的顶级actor（如日志监听器或由配置指定在actor系统启动时自动部署的actor）的监管者</li>
<li><tt class="docutils literal"><span class="pre">&quot;/deadLetters&quot;</span></tt> 是死信actor，所有发往已经终止或不存在的actor的消息会被送到这里</li>
<li><tt class="docutils literal"><span class="pre">&quot;/temp&quot;</span></tt> 是所有系统创建的短时actor(i.e.那些用在<tt class="xref py py-meth docutils literal"><span class="pre">ActorRef.ask</span></tt>的实现中的actor)的监管者.</li>
<li><tt class="docutils literal"><span class="pre">&quot;/remote&quot;</span></tt> 是一个人造的路径，用来存放所有其监管者是远程actor引用的actor</li>
</ul>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">目录</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="javascript:if(confirm('http://akka.io/docs  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/docs'" tppabs="http://akka.io/docs">Documentation</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/downloads  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/downloads'" tppabs="http://akka.io/downloads">Downloads</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/news  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/news'" tppabs="http://akka.io/news">News</a></li>
      <li><a href="javascript:if(confirm('http://letitcrash.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://letitcrash.com/'" tppabs="http://letitcrash.com/">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="javascript:if(confirm('http://github.com/akka/akka  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://github.com/akka/akka'" tppabs="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="javascript:if(confirm('http://groups.google.com/group/akka-user  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://groups.google.com/group/akka-user'" tppabs="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="javascript:if(confirm('http://www.assembla.com/spaces/akka/tickets  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.assembla.com/spaces/akka/tickets'" tppabs="http://www.assembla.com/spaces/akka/tickets">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="javascript:if(confirm('http://typesafe.com/products/typesafe-subscription  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://typesafe.com/products/typesafe-subscription'" tppabs="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/team  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/team'" tppabs="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" tppabs="http://www.gtan.com/akka_doc/_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2012 <a href="javascript:if(confirm('http://typesafe.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://typesafe.com/'" tppabs="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Mar 08, 2012
    </p>          
  </div>
</div>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>
<!-- Localized -->