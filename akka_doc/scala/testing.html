


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>测试 Actor 系统 (Scala) &mdash; Akka Documentation</title>
    <link rel="stylesheet" href="../_static/style.css" tppabs="http://www.gtan.com/akka_doc/_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" tppabs="http://www.gtan.com/akka_doc/_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" tppabs="http://www.gtan.com/akka_doc/_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" tppabs="http://www.gtan.com/akka_doc/_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" tppabs="http://www.gtan.com/akka_doc/_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="../../../fonts.googleapis.com/css-family=Exo-300,400,600,700.css" tppabs="http://fonts.googleapis.com/css?family=Exo:300,400,600,700" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js" tppabs="http://www.gtan.com/akka_doc/_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js" tppabs="http://www.gtan.com/akka_doc/_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js" tppabs="http://www.gtan.com/akka_doc/_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js" tppabs="http://www.gtan.com/akka_doc/_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js" tppabs="http://www.gtan.com/akka_doc/_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js" tppabs="http://www.gtan.com/akka_doc/_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js" tppabs="http://www.gtan.com/akka_doc/_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js" tppabs="http://www.gtan.com/akka_doc/_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js" tppabs="http://www.gtan.com/akka_doc/_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js" tppabs="http://www.gtan.com/akka_doc/_static/contentsFix.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="Scala API" href="index.html" />
    <link rel="next" title="TestKit Example (Scala)" href="testkit-example.html" />
    <link rel="prev" title="IO (Scala)" href="io.html" /> 
  </head>
  <body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="javascript:if(confirm('http://akka.io/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/'" tppabs="http://akka.io/"><img src="../_static/logo-small.png" tppabs="http://www.gtan.com/akka_doc/_static/logo-small.png" /></a>
        </div>    
        <ul class="nav">
          <li><a href="javascript:if(confirm('http://www.gtan.com/welfare04.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.gtan.com/welfare04.html'" tppabs="http://www.gtan.com/welfare04.html">返回广谈公益</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">测试 Actor 系统 (Scala)</div><div class="pdf-link"><a href="javascript:if(confirm('http://www.gtan.com/akka_doc/Akka.pdf  \n\nļ޷ Teleport Ultra , Ϊ ļδҵ  \n\nڷϴ?'))window.location='http://www.gtan.com/akka_doc/Akka.pdf'" tppabs="http://www.gtan.com/akka_doc/Akka.pdf"><img src="../_static/pdf-icon.png" tppabs="http://www.gtan.com/akka_doc/_static/pdf-icon.png" style="height: 40px;" /></a></div></div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="testkit-example.html" tppabs="http://www.gtan.com/akka_doc/scala/testkit-example.html">TestKit 实例 (Scala)</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html" tppabs="http://www.gtan.com/akka_doc/index.html">目录</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="io.html" tppabs="http://www.gtan.com/akka_doc/scala/io.html">IO (Scala)</a> <span class="divider">|</span>
              </li>
              <li>
                版本 2.0
              </li>
            </ul>         
          </div>
        </div>
        <div class="row">
          <div class="span9">
            
  <div class="section" id="testing-actor-systems-scala">
<span id="akka-testkit"></span><h1>测试 Actor 实例 (Scala)</h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="testkit-example.html" tppabs="http://www.gtan.com/akka_doc/scala/testkit-example.html">TestKit 实例 (Scala)</a></li>
</ul>
</div>
<p>对于任何软件开发，自动化测试都是开发过程的一个重要组成部分. actor 模型对于代码单元如何划分，它们之间如何交互提供了一种新的视角，
    这对如何编写测试也造成了影响.</p>
<p>Akka 有一个专门的 <tt class="xref py py-mod docutils literal"><span class="pre">akka-testkit</span></tt> 模块来支持不同层次上的测试,
    很明显共有两个类别:</p>
<blockquote>
<div><ul class="simple">
<li>测试独立的不包括actor模型的代码，即没有多线程的内容；在事件发生的次序方面有完全确定性的行为，没有任何并发考虑，
    这在下文中称为 <strong>单元测试（Unit Testing）</strong> .</li>
<li>测试（多个）包装过的actor，包括多线程调度; 事件的次序没有确定性但由于使用了actor模型，不需要考虑并发，这在下文中被称为
    <strong>集成测试（Integration Testing）</strong> .</li>
</ul>
</div></blockquote>
<p>当然这两个类型有着不同的粒度, 单元测试通常是白盒测试而集成测试是对完整的actor网络进行的功能测试。
    其中重要的区别是并发的考虑是否是测试是一部分。我们提供的工具将在下面的章节中详细介绍。</p>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p class="last">请确保在依赖项中加入 <tt class="xref py py-mod docutils literal"><span class="pre">akka-testkit</span></tt> 模块.</p>
</div>
<div class="section" id="unit-testing-with-testactorref">
<h2>用<tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt>做单元测试</h2>
<p>测试<tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> 类中的业务逻辑分为两部分:
    首先，每个原子操作必须独立动作，然后输入的事件序列必须被正确处理, 即使事件的次序存在一些可能的变化. 前者是单线程单元测试的主要使用场景，而后者可以在集成测试中进行确认。</p>
<p>通常， <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt> 将实际的
    <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> 实例与外界隔离开, 唯一的通信通道是actor的邮箱.
    这个限制是单元测试的障碍，所以我们引进了<tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt>.
    这个特殊类型的引用是专门为测试的上的的，它允许以两种方式访问actor: 通过获取实际actor实例的引用，通过调用或查询actor的行为
    (<tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt>). 以下每一种方式都有专门的部分介绍。</p>
<div class="section" id="obtaining-a-reference-to-an-actor">
<h3>获取 <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> 的引用</h3>
<p>能够访问到实际的 <tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> 对象使得所有传统的单元测试方法可以用于测试其中的方法.
    获取引用的方法:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestActorRef</span>

<span class="k">val</span> <span class="n">actorRef</span> <span class="k">=</span> <span class="nc">TestActorRef</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">actorRef</span><span class="o">.</span><span class="n">underlyingActor</span>
</pre></div>
</div>
<p>由于 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 是actor类型的高阶类型，它返回实际actor和其正确静态类型。这样之后
    你就可以象平常一样将你的任何单元测试工具用于你的actor.</p>
</div>
<div class="section" id="expecting-exceptions">
<h3>预料中的异常</h3>
<p>测试处理消息时抛出的预料中的异常可以使用基于 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt>
    的调用 :</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestActorRef</span>

<span class="k">val</span> <span class="n">actorRef</span> <span class="k">=</span> <span class="nc">TestActorRef</span><span class="o">(</span><span class="k">new</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">boom</span> <span class="k">⇒</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;boom&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">})</span>
<span class="n">intercept</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="o">{</span> <span class="n">actorRef</span><span class="o">.</span><span class="n">receive</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-finite-state-machines">
<span id="testfsmref"></span><h3>测试有限状态机</h3>
<p>如果你要测试的actor是一个 <tt class="xref py py-class docutils literal"><span class="pre">FSM</span></tt>, 你可以使用专门的
<tt class="xref py py-class docutils literal"><span class="pre">TestFSMRef</span></tt>，它拥有普通 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt>
    的所有功能，并且能够访问其内部状态:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestFSMRef</span>
<span class="k">import</span> <span class="nn">akka.actor.FSM</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>

<span class="k">val</span> <span class="n">fsm</span> <span class="k">=</span> <span class="nc">TestFSMRef</span><span class="o">(</span><span class="k">new</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">startWith</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
  <span class="n">when</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="s">&quot;go&quot;</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">goto</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="n">using</span> <span class="s">&quot;go&quot;</span>
  <span class="o">}</span>
  <span class="n">when</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="s">&quot;back&quot;</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">⇒</span> <span class="n">goto</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="n">using</span> <span class="s">&quot;back&quot;</span>
  <span class="o">}</span>
<span class="o">})</span>

<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">stateName</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">stateData</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
<span class="n">fsm</span> <span class="o">!</span> <span class="s">&quot;go&quot;</span> <span class="c1">// being a TestActorRef, this runs also on the CallingThreadDispatcher</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">stateName</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">stateData</span> <span class="o">==</span> <span class="s">&quot;go&quot;</span><span class="o">)</span>

<span class="n">fsm</span><span class="o">.</span><span class="n">setState</span><span class="o">(</span><span class="n">stateName</span> <span class="k">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">stateName</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">timerActive_?</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span>
<span class="n">fsm</span><span class="o">.</span><span class="n">setTimer</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">10</span> <span class="n">millis</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">timerActive_?</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span>
<span class="n">fsm</span><span class="o">.</span><span class="n">cancelTimer</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span>
<span class="n">assert</span><span class="o">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">timerActive_?</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span>
</pre></div>
</div>
<p>由于Scala类型推测的限制，只有一个如上所示的工厂方法，所以你可能需要写象 <tt class="docutils literal"><span class="pre">TestFSMRef(new</span> <span class="pre">MyFSM)</span></tt>
    这样的代码，而不是想象中的类似<tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>的<tt class="docutils literal"><span class="pre">TestFSMRef[MyFSM]</span></tt>.
上例所示的所有方法都直接访问FSM的状态，不作任何同步；这在使用
<tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>
    (<tt class="xref py py-class docutils literal"><span class="pre">TestFSMRef</span></tt>缺省使用它) 并且没有其它线程参与的情况下是合适的, 但如果你实际上需要
    处理定时器事件可能会导致意外的情形，因为它们是在 <tt class="xref py py-obj docutils literal"><span class="pre">Scheduler</span></tt> 线程中执行的.</p>
</div>
<div class="section" id="testing-the-actor-s-behavior">
<h3>测试Actor的行为</h3>
<p>当消息派发器调用actor中的逻辑来处理消息时，它实际上是对当前注册到actor的行为进行了<tt class="xref py py-meth docutils literal"><span class="pre">apply</span></tt> .
    行为的初始值是代码中声明的 <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> 方法的返回值,
    但可以通过对外部消息的响应调用 <tt class="xref py py-meth docutils literal"><span class="pre">become</span></tt> 和 <tt class="xref py py-meth docutils literal"><span class="pre">unbecome</span></tt>
    来改变这个行为. 所有这些特性使得actor的行为测试起来不太容易。因此 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 提供了一种不同的操作方式来
    对<tt class="xref py py-class docutils literal"><span class="pre">Actor</span></tt> 的测试进行补充: 它支持所有正常的
    <tt class="xref py py-class docutils literal"><span class="pre">ActorRef</span></tt>中的操作. 发往actor的消息在当前线程中同步处理，应答象正常一样回送。
    这个技巧来自下面所介绍的 <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>; 这个派发器被隐式地用于所有
 实例化为<tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt>的actor.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestActorRef</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.dispatch.Await</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>

<span class="k">val</span> <span class="n">actorRef</span> <span class="k">=</span> <span class="nc">TestActorRef</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyActor</span><span class="o">)</span>
<span class="c1">// 假设消息计算出结果 &#39;42&#39; </span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">((</span><span class="n">actorRef</span> <span class="o">?</span> <span class="nc">Say42</span><span class="o">),</span> <span class="mi">5</span> <span class="n">seconds</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">result</span> <span class="n">must</span> <span class="n">be</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></div>
</div>
<p>由于 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 是 <tt class="xref py py-class docutils literal"><span class="pre">LocalActorRef</span></tt> 的子类，
    只不过多加了一些特殊功能，所以象监管和重启也能正常工作，但是要知道只要所有的相关的actor都使用 <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>那么所有的执行过程都是严格同步的.
    一旦你增加了一些元素，其中包括比较复杂的定时任务，你就离开了单元测试的范畴，因为你必须要重新将异步性纳入考虑范围（在大多数情况下问题在于要等待希望的结果有机会发生）.</p>
<p>另一个在单线程测试中被覆盖的特殊点是
<tt class="xref py py-meth docutils literal"><span class="pre">receiveTimeout</span></tt>, 由于包含了它会产生异步的
<tt class="xref py py-obj docutils literal"><span class="pre">ReceiveTimeout</span></tt> 消息队列, 因此与同步约定矛盾.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">综上所述: <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 重写了两个成员: 它设置派发器为
 <tt class="xref py py-obj docutils literal"><span class="pre">CallingThreadDispatcher.global</span></tt> ，设置
<tt class="xref py py-obj docutils literal"><span class="pre">receiveTimeout</span></tt> 为 None.</p>
</div>
</div>
<div class="section" id="the-way-in-between">
<h3>介于两者之间方法</h3>
<p>如果你希望测试actor的行为，包括热替换，但是不包括消息派发器，也不希望 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 吞掉所有抛出的异常,
    那么为你准备了另一种模式: 只要使用 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 的 <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> 方法 ,
    这将会把消息转发给内部的 actor:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestActorRef</span>
<span class="n">system</span><span class="o">.</span><span class="n">eventStream</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">UnhandledMessage</span><span class="o">])</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="nc">TestActorRef</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="n">ref</span><span class="o">.</span><span class="n">receive</span><span class="o">(</span><span class="nc">Unknown</span><span class="o">)</span>
<span class="n">expectMsg</span><span class="o">(</span><span class="mi">1</span> <span class="n">second</span><span class="o">,</span> <span class="nc">UnhandledMessage</span><span class="o">(</span><span class="nc">Unknown</span><span class="o">,</span> <span class="n">system</span><span class="o">.</span><span class="n">deadLetters</span><span class="o">,</span> <span class="n">ref</span><span class="o">))</span>
</pre></div>
</div>
<p>上面的例子假设使用未处理消息的缺省行为，i.e. actor不会吞掉所有的消息并且没有重写 <tt class="xref py py-meth docutils literal"><span class="pre">unhandled</span></tt>.</p>
</div>
<div class="section" id="use-cases">
<h3>使用场景</h3>
<p>当然你也可以根据自己的测试需求来混合使用 <tt class="xref py py-class docutils literal"><span class="pre">TestActorRef</span></tt> 的不同用法:</p>
<blockquote>
<div><ul class="simple">
<li>一个常见的使用场景是在发送测试消息之前设置actor进入某个特定的内部状态</li>
<li>另一个场景是发送了测试消息之后确认正确的内部状态转换</li>
</ul>
</div></blockquote>
<p>放心大胆地对各种可能性进行实验，如果你发现了有用的模式，快让Akka论坛知道它！天知道，常用操作也许能放进优美的DSL中。</p>
</div>
</div>
<div class="section" id="integration-testing-with-testkit">
<h2>用<tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt>进行集成测试</h2>
<p>当你基本确定你的actor的业务逻辑是正确的, 下一个步骤就是确认它在目标环境中也能正确工作
(如果actor分别都比较简单，可能是因为他们使用了
<tt class="xref py py-mod docutils literal"><span class="pre">FSM</span></tt> 模块, 这也可以放到第一步). 关于环境的定义当然很大程度上由手上的问题和
    你打算测试的程度决定, 从功能/集成测试到完整的系统测试. 最简单的步骤包括测试流程（说明测试条件）、要测试的actir和接收应答的actor。大一些的系统将被测的actor替换成一组actor网络，将测试
    条件应用于不同的切入点，并整理将会从不同的输出位置发送的结果，但基本的原则是测试由一个单独的流程来驱动。</p>
<p> <tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt> 类包含一组工具来简化这些常用的工作.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.testkit.TestKit</span>
<span class="k">import</span> <span class="nn">org.scalatest.WordSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.matchers.MustMatchers</span>
<span class="k">import</span> <span class="nn">org.scalatest.BeforeAndAfterAll</span>
<span class="k">import</span> <span class="nn">akka.testkit.ImplicitSender</span>

<span class="k">object</span> <span class="nc">MySpec</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">EchoActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">x</span> <span class="k">⇒</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">x</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">MySpec</span><span class="o">(</span><span class="nc">_system</span><span class="k">:</span> <span class="kt">ActorSystem</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">TestKit</span><span class="o">(</span><span class="nc">_system</span><span class="o">)</span> <span class="k">with</span> <span class="nc">ImplicitSender</span>
  <span class="k">with</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">MustMatchers</span> <span class="k">with</span> <span class="nc">BeforeAndAfterAll</span> <span class="o">{</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MySpec&quot;</span><span class="o">))</span>

  <span class="k">import</span> <span class="nn">MySpec._</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">afterAll</span> <span class="o">{</span>
    <span class="n">system</span><span class="o">.</span><span class="n">shutdown</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="s">&quot;An Echo actor&quot;</span> <span class="n">must</span> <span class="o">{</span>

    <span class="s">&quot;send back messages unchanged&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">echo</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">EchoActor</span><span class="o">])</span>
      <span class="n">echo</span> <span class="o">!</span> <span class="s">&quot;hello world&quot;</span>
      <span class="n">expectMsg</span><span class="o">(</span><span class="s">&quot;hello world&quot;</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p> <tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt> 中有一个名为
    <tt class="xref py py-obj docutils literal"><span class="pre">testActor</span></tt> 的actor作为将要被不同的
    <tt class="docutils literal"><span class="pre">expectMsg...</span></tt>断言检查的消息的入口，下面会详细介绍这些断言。
当混入了 <tt class="docutils literal"><span class="pre">ImplicitSender</span></tt> trait后
    这个actor在从测试过程中派发消息时将被隐式地用作发送引用.  <tt class="xref py py-obj docutils literal"><span class="pre">testActor</span></tt> 也可以被
    象平常一样发送给其它的actor，通常是订阅成为通知监听器. 有一堆检查方法, e.g. 接收所有匹配某些条件的消息，接收固定的消息序列或类，在某段时间内收不到消息，等。</p>
<p>记得在测试完成后关闭actor系统 (即使是在测试失败的情况下) 以保证所有的actor-包括测试actor-被停止.</p>
<div class="section" id="built-in-assertions">
<h3>内置断言</h3>
<p>上面提到的 <tt class="xref py py-meth docutils literal"><span class="pre">expectMsg</span></tt> 并不是唯一的对收到的消息进行断言的方法. 以下是完整的列表:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsg[T](d:</span> <span class="pre">Duration,</span> <span class="pre">msg:</span> <span class="pre">T):</span> <span class="pre">T</span></tt></p>
<p>给定的消息必须在指定的时间内到达；返回此消息.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgPF[T](d:</span> <span class="pre">Duration)(pf:</span> <span class="pre">PartialFunction[Any,</span> <span class="pre">T]):</span> <span class="pre">T</span></tt></p>
<p>在给定的时间内，必须有消息到达，必须为这类消息定义了偏函数；返回偏函数应用到收到的消息的结果。可以不指定时间段（这时需要一对空的括号），
    这时使用最深层的 <a class="reference internal" href="#testkit-within"><em>within</em></a> 块中的期限.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgClass[T](d:</span> <span class="pre">Duration,</span> <span class="pre">c:</span> <span class="pre">Class[T]):</span> <span class="pre">T</span></tt></p>
<p>在指定的时间内必须接收到 <tt class="xref py py-class docutils literal"><span class="pre">Class</span></tt> 类型的对象；返回收到的对象。
    注意它的类型匹配是子类兼容的；如果需要类型是相等的，参考使用单个class参数的
<tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAllClassOf</span></tt> 。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgType[T:</span> <span class="pre">Manifest](d:</span> <span class="pre">Duration)</span></tt></p>
<p>在指定的时间内必须收到指定类型 (擦除后)的对象; 返回收到的对象。这个方法基本上与
<tt class="docutils literal"><span class="pre">expectMsgClass(manifest[T].erasure)</span></tt>等价.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAnyOf[T](d:</span> <span class="pre">Duration,</span> <span class="pre">obj:</span> <span class="pre">T*):</span> <span class="pre">T</span></tt></p>
<p>在指定的时间内必须收到一个对象，而且此对象必须与传入的对象引用中的一个相等(
用 <tt class="docutils literal"><span class="pre">==</span></tt> 进行比较); 返回收到的对象.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAnyClassOf[T](d:</span> <span class="pre">Duration,</span> <span class="pre">obj:</span> <span class="pre">Class[_</span> <span class="pre">&lt;:</span> <span class="pre">T]*):</span> <span class="pre">T</span></tt></p>
<p>在指定的时间内必须收到一个对象，它必须至少是指定的某 <tt class="xref py py-class docutils literal"><span class="pre">Class</span></tt> 对象的实例; 返回收到的对象.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAllOf[T](d:</span> <span class="pre">Duration,</span> <span class="pre">obj:</span> <span class="pre">T*):</span> <span class="pre">Seq[T]</span></tt></p>
<p>在指定时间内必须收到与指定的数组中相等数量的对象, 对每个收到的对象，必须至少有一个数组中的对象与它相等(用<tt class="docutils literal"><span class="pre">==</span></tt>进行比较) .
    返回收到的整个对象集合.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAllClassOf[T](d:</span> <span class="pre">Duration,</span> <span class="pre">c:</span> <span class="pre">Class[_</span> <span class="pre">&lt;:</span> <span class="pre">T]*):</span> <span class="pre">Seq[T]</span></tt></p>
<p>在指定时间内必须收到与指定的 <tt class="xref py py-class docutils literal"><span class="pre">Class</span></tt> 数组中相等数量的对象，对数组中的每一个Class，
    必须至少有一个对象的Class与它相等(用 <tt class="docutils literal"><span class="pre">==</span></tt>进行比较)  (这 <em>不是</em> 子类兼容的类型检查).
    返回收到的整个对象集合.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectMsgAllConformingOf[T](d:</span> <span class="pre">Duration,</span> <span class="pre">c:</span> <span class="pre">Class[_</span> <span class="pre">&lt;:</span> <span class="pre">T]*):</span> <span class="pre">Seq[T]</span></tt></p>
<p>在指定时间内必须收到与指定的 <tt class="xref py py-class docutils literal"><span class="pre">Class</span></tt> 数组中相等数量的对象，对数组中的每个Class
必须至少有一个对象是这个Class的实例。返回收到的整个对象集合。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">expectNoMsg(d:</span> <span class="pre">Duration)</span></tt></p>
<p>在指定时间内不能收到消息。如果在这个方法被调用之前已经收到了消息，并且没有用其它的方法将这些消息从队列中删除，这个断言也会失败。</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">receiveN(n:</span> <span class="pre">Int,</span> <span class="pre">d:</span> <span class="pre">Duration):</span> <span class="pre">Seq[AnyRef]</span></tt></p>
<p>指定的时间内必须收到<tt class="docutils literal"><span class="pre">n</span></tt> 条消息; 返回收到的消息.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">fishForMessage(max:</span> <span class="pre">Duration,</span> <span class="pre">hint:</span> <span class="pre">String)(pf:</span> <span class="pre">PartialFunction[Any,</span> <span class="pre">Boolean]):</span> <span class="pre">Any</span></tt></p>
<p>只要时间没有用完，并且偏函数匹配消息并返回<tt class="docutils literal"><span class="pre">false</span></tt>就一直接收消息. 返回使偏函数返回<tt class="docutils literal"><span class="pre">true</span></tt>
    的消息或抛出异常, 异常中会提供一些提示以供debug使用。</p>
</li>
</ul>
</div></blockquote>
<p>除了接收消息的断言，还有一些方法来对消息流提供帮助:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">receiveOne(d:</span> <span class="pre">Duration):</span> <span class="pre">AnyRef</span></tt></p>
<p>尝试等待给定的时间以等待收到一个消息，如果失败则返回<tt class="docutils literal"><span class="pre">null</span></tt> . 如果给定的 Duration 是0，这一调用是非阻塞的(轮询模式).</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">receiveWhile[T](max:</span> <span class="pre">Duration,</span> <span class="pre">idle:</span> <span class="pre">Duration,</span> <span class="pre">messages:</span> <span class="pre">Int)(pf:</span> <span class="pre">PartialFunction[Any,</span> <span class="pre">T]):</span> <span class="pre">Seq[T]</span></tt></p>
<p>只要满足</p>
<ul class="simple">
<li>消息与偏函数匹配</li>
<li>指定的时间还没用完</li>
<li>在空闲的时间内收到了下一条消息</li>
<li>消息数量还没有到上限</li>
</ul>
    <p>就收集消息</p>
<p>返回收集到的所有消息. 时间上限缺省值是最深层的 <a class="reference internal" href="#testkit-within"><em>within</em></a>块中剩余的时间，空闲时间缺省为无限
    (也就是禁止空闲超时功能). 期望的消息数量缺省值为
<tt class="docutils literal"><span class="pre">Int.MaxValue</span></tt>, 也就是不作这个限制.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">awaitCond(p:</span> <span class="pre">=&gt;</span> <span class="pre">Boolean,</span> <span class="pre">max:</span> <span class="pre">Duration,</span> <span class="pre">interval:</span> <span class="pre">Duration)</span></tt></p>
<p>每经过 <tt class="xref py py-obj docutils literal"><span class="pre">interval</span></tt> 时间就检查一下给定的条件，直到它返回 <tt class="docutils literal"><span class="pre">true</span></tt> 或者
    <tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt> 时间用完了. 时间间隔缺省为 100 ms 而最大值缺省为最深层的
<a class="reference internal" href="#testkit-within"><em>within</em></a> 块中的剩余时间.</p>
</li>
<li><p class="first"><tt class="xref py py-meth docutils literal"><span class="pre">ignoreMsg(pf:</span> <span class="pre">PartialFunction[AnyRef,</span> <span class="pre">Boolean])</span></tt></p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">ignoreNoMsg</span></tt></p>
<p>内部的 <tt class="xref py py-obj docutils literal"><span class="pre">testActor</span></tt> 包含一个偏函数用来忽略消息:
    它只会将与偏函数不匹配或使函数返回<tt class="docutils literal"><span class="pre">false</span></tt>的消息放进队列。 这个函数可以用上面的方法进行设置和
    重设; 每一次调用都会覆盖之前的函数，而不会迭加.</p>
<p>这个功能在你想到忽略正常的消息而只对你指定的一些消息感兴趣时（e.g. 测试日志系统时）比较有用。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id1">
<h3>预料的异常</h3>
<p>由于集成测试无法进入参与测试的actor的内部处理流程, 无法直接确认预料中的异常.
为了做这件事，只能使用日志系统：将普通的事件处理器替换成 <tt class="xref py py-class docutils literal"><span class="pre">TestEventListener</span></tt>
    然后使用 <tt class="xref py py-class docutils literal"><span class="pre">EventFilter</span></tt>
可以对日志信息，包括由于异常产生的日志，做断言:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.EventFilter</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;testsystem&quot;</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">  akka.event-handlers = [&quot;akka.testkit.TestEventListener&quot;]</span>
<span class="s">  &quot;&quot;&quot;</span><span class="o">))</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="nc">EventFilter</span><span class="o">[</span><span class="kt">ActorKilledException</span><span class="o">](</span><span class="n">occurrences</span> <span class="k">=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">intercept</span> <span class="o">{</span>
    <span class="n">actor</span> <span class="o">!</span> <span class="nc">Kill</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  <span class="n">system</span><span class="o">.</span><span class="n">shutdown</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="timing-assertions">
<span id="testkit-within"></span><h3>对定时进行断言</h3>
<p>功能测试的另一个重要部分与定时器有关：有些事件不能立即发生（如定时器）, 另外一些需要在时间期限内发生. 因此所有的进行检查的方法
    都接收一个时间上限，不论是正面还是负面的结果都应该在这个时间之前获得。时间下限需要在这个检测方法之外进行检查，我们有一个新的工具来管理时间期限:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">within</span><span class="o">([</span><span class="kt">min</span>, <span class="o">]</span><span class="n">max</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p> <tt class="xref py py-meth docutils literal"><span class="pre">within</span></tt>所带的代码块必须在一个介于
<tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt> 和 <tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>之间的<a class="reference internal" href="../common/duration.html#duration" tppabs="http://www.gtan.com/akka_doc/common/duration.html#duration"><em>Duration</em></a>之前完成,
    其中min缺省值为0. 将The
 <tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt> 参数与块的启动时间相加得到的时间期限在所有检查方法块内部都可以隐式得获得，
   如果你没有指定max值，它会从最深层的
<tt class="xref py py-meth docutils literal"><span class="pre">within</span></tt> 块继承这个值.</p>
<p>应注意如果代码块的最后一条接收消息断言是
<tt class="xref py py-meth docutils literal"><span class="pre">expectNoMsg</span></tt> 或 <tt class="xref py py-meth docutils literal"><span class="pre">receiveWhile</span></tt>,
    对
<tt class="xref py py-meth docutils literal"><span class="pre">within</span></tt> 的最终检查将被跳过，以避免由于唤醒延迟导致的错误的true值.
    这意味着虽然其中每一个独立的断言仍然使用时间上限，整个代码块在这种情况下会有长度随机的延迟。</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>

<span class="k">val</span> <span class="n">worker</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Worker</span><span class="o">])</span>
<span class="n">within</span><span class="o">(</span><span class="mi">200</span> <span class="n">millis</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">worker</span> <span class="o">!</span> <span class="s">&quot;some work&quot;</span>
  <span class="n">expectMsg</span><span class="o">(</span><span class="s">&quot;some result&quot;</span><span class="o">)</span>
  <span class="n">expectNoMsg</span> <span class="c1">// 在剩下的200ms中会阻塞</span>
  <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">300</span><span class="o">)</span> <span class="c1">// 不会使当前代码块失败</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注意</p>
<p class="last">所有的时间都以 <tt class="docutils literal"><span class="pre">System.nanoTime</span></tt>为单位, 它们描述的是墙上时间，而非CPU时间.</p>
</div>
<p>Ray Roestenburg 写了一篇关于使用 TestKit 的好文:
<a class="reference external" href="javascript:if(confirm('http://roestenburg.agilesquad.com/2011/02/unit-testing-akka-actors-with-testkit_12.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://roestenburg.agilesquad.com/2011/02/unit-testing-akka-actors-with-testkit_12.html'" tppabs="http://roestenburg.agilesquad.com/2011/02/unit-testing-akka-actors-with-testkit_12.html">http://roestenburg.agilesquad.com/2011/02/unit-testing-akka-actors-with-testkit_12.html</a>.
完整的示例也可以在 <a class="reference internal" href="testkit-example.html#testkit-example" tppabs="http://www.gtan.com/akka_doc/scala/testkit-example.html#testkit-example"><em>here</em></a>这儿找到.</p>
<div class="section" id="accounting-for-slow-test-systems">
<h4>考虑很慢的测试系统</h4>
<p>你在跑得飞快的笔记本上使用的超时设置在高负载的Jenkins（或类似的）服务器上通常都会导致错误的测试失败。
    为了考虑这种情况，所有的时间上限都在内部乘以一个系数，这个系数来自 <a class="reference internal" href="../general/configuration.html#configuration" tppabs="http://www.gtan.com/akka_doc/general/configuration.html#configuration"><em>配置文件</em></a>中的
<tt class="docutils literal"><span class="pre">akka.test.timefactor</span></tt>, 缺省值为 1.</p>
<p>你也可以用<tt class="docutils literal"><span class="pre">akka.testkit</span></tt>包对象中的隐式转换来将同样的系数来作用于其它的时限，为
    <tt class="xref py py-class docutils literal"><span class="pre">Duration</span></tt> dilated函数.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.testkit._</span>
<span class="mf">10.</span><span class="n">milliseconds</span><span class="o">.</span><span class="n">dilated</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="resolving-conflicts-with-implicit-actorref">
<h3>用隐式的ActorRef解决冲突</h3>
<p>如果你希望在基于TestKit的测试的消息发送者为 <tt class="docutils literal"><span class="pre">testActor</span></tt>
只需要为你的测试代码混入 <tt class="docutils literal"><span class="pre">ÌmplicitSender</span></tt> .</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MySpec</span><span class="o">(</span><span class="nc">_system</span><span class="k">:</span> <span class="kt">ActorSystem</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">TestKit</span><span class="o">(</span><span class="nc">_system</span><span class="o">)</span> <span class="k">with</span> <span class="nc">ImplicitSender</span>
  <span class="k">with</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">MustMatchers</span> <span class="k">with</span> <span class="nc">BeforeAndAfterAll</span> <span class="o">{</span>
</pre></div>
</div>
</div>
<div class="section" id="using-multiple-probe-actors">
<h3>使用多个探针 Actor</h3>
<p>如果待测的actor会发送多个消息到不同的目标，在使用<tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt>时可能会难以分辨到达
    <tt class="xref py py-obj docutils literal"><span class="pre">testActor</span></tt>的消息流. 另一种方法是用它来创建简单的探针actor，将它们插入到消息流中.
    为了让这种方法更加强大和方便，我们提供了一个具体实现，称为 <tt class="xref py py-class docutils literal"><span class="pre">TestProbe</span></tt>.
    它的功能可以用下面的小例子说明:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.TestProbe</span>
<span class="k">import</span> <span class="nn">akka.util.duration._</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">akka.dispatch.Futures</span>

  <span class="k">class</span> <span class="nc">MyDoubleEcho</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">dest1</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="k">_</span>
    <span class="k">var</span> <span class="n">dest2</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="k">_</span>
    <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">d1</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">d2</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">⇒</span>
        <span class="n">dest1</span> <span class="k">=</span> <span class="n">d1</span>
        <span class="n">dest2</span> <span class="k">=</span> <span class="n">d2</span>
      <span class="k">case</span> <span class="n">x</span> <span class="k">⇒</span>
        <span class="n">dest1</span> <span class="o">!</span> <span class="n">x</span>
        <span class="n">dest2</span> <span class="o">!</span> <span class="n">x</span>
    <span class="o">}</span>
  <span class="o">}</span>

    <span class="k">val</span> <span class="n">probe1</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">probe2</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">actor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyDoubleEcho</span><span class="o">])</span>
    <span class="n">actor</span> <span class="o">!</span> <span class="o">(</span><span class="n">probe1</span><span class="o">.</span><span class="n">ref</span><span class="o">,</span> <span class="n">probe2</span><span class="o">.</span><span class="n">ref</span><span class="o">)</span>
    <span class="n">actor</span> <span class="o">!</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">probe1</span><span class="o">.</span><span class="n">expectMsg</span><span class="o">(</span><span class="mi">500</span> <span class="n">millis</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>
    <span class="n">probe2</span><span class="o">.</span><span class="n">expectMsg</span><span class="o">(</span><span class="mi">500</span> <span class="n">millis</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>这里我们用 <tt class="xref py py-class docutils literal"><span class="pre">MyDoubleEcho</span></tt>来仿真一个待测系统, 它会将输入镜像为两个输出.
    关联两个测试探针来进行（最简单）行为的确认. 还有一个例子是两个 actor
A，B， A 发送消息给 B. 为了确认这个消息流，可以插入 <tt class="xref py py-class docutils literal"><span class="pre">TestProbe</span></tt> 作为A的目标,
    使用转发功能或下文中的自动导向功能在测试上下文中包含真实的B.</p>
<p>还可以为探针配备自定义的断言来使测试代码更简洁清晰:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Update</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">val</span> <span class="n">probe</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TestProbe</span><span class="o">(</span><span class="n">system</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">expectUpdate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">expectMsgPF</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Update</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="k">if</span> <span class="n">id</span> <span class="o">==</span> <span class="n">x</span> <span class="k">⇒</span> <span class="kc">true</span>
    <span class="o">}</span>
    <span class="n">sender</span> <span class="o">!</span> <span class="s">&quot;ACK&quot;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>这里你拥有完全的灵活性，可以将<tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt>
提供的工具与你自己的检测代码混合和匹配，并为它取一个有意义的名字。在实际中你的代码可能比上面的示例要复杂；要充分利用工具！</p>
<div class="section" id="replying-to-messages-received-by-probes">
<h4>对探针收到的消息进行应答</h4>
<p>探针在可能的条件下，会记录通讯通道以便进行应答:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">probe</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">probe</span><span class="o">.</span><span class="n">ref</span> <span class="o">?</span> <span class="s">&quot;hello&quot;</span>
<span class="n">probe</span><span class="o">.</span><span class="n">expectMsg</span><span class="o">(</span><span class="mi">0</span> <span class="n">millis</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="c1">// TestActor 运行在 CallingThreadDispatcher 上</span>
<span class="n">probe</span><span class="o">.</span><span class="n">sender</span> <span class="o">!</span> <span class="s">&quot;world&quot;</span>
<span class="n">assert</span><span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="n">isCompleted</span> <span class="o">&amp;&amp;</span> <span class="n">future</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="forwarding-messages-received-by-probes">
<h4>对探针收到的消息进行转发</h4>
<p>假定一个象征性的actor网络中某目标 actor <tt class="docutils literal"><span class="pre">dest</span></tt> 从
    actor <tt class="docutils literal"><span class="pre">source</span></tt>收到一条消息.
    如果你使消息先发往 <tt class="xref py py-class docutils literal"><span class="pre">TestProbe</span></tt>
    <tt class="docutils literal"><span class="pre">probe</span></tt> , 你可以在保持网络功能的同时对消息流的容量和时限进行断言:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Source</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;start&quot;</span> <span class="k">⇒</span> <span class="n">target</span> <span class="o">!</span> <span class="s">&quot;work&quot;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="k">⇒</span> <span class="c1">// Do something..</span>
  <span class="o">}</span>
<span class="o">}</span>

  <span class="k">val</span> <span class="n">probe</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
  <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Source</span><span class="o">(</span><span class="n">probe</span><span class="o">.</span><span class="n">ref</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">dest</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Destination</span><span class="o">])</span>
  <span class="n">source</span> <span class="o">!</span> <span class="s">&quot;start&quot;</span>
  <span class="n">probe</span><span class="o">.</span><span class="n">expectMsg</span><span class="o">(</span><span class="s">&quot;work&quot;</span><span class="o">)</span>
  <span class="n">probe</span><span class="o">.</span><span class="n">forward</span><span class="o">(</span><span class="n">dest</span><span class="o">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">dest</span></tt> actor 先收到同样的消息，就象没有插入探针一样.</p>
</div>
<div class="section" id="auto-pilot">
<h4>自动导向</h4>
<p>将收到的消息放进队列以便以后处理，这种方法不错，但要保持测试运行并对其运行过程进行跟踪，你也可以为参与测试的探针(事实上是任何
    <tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt>)安装一个
<tt class="xref py py-class docutils literal"><span class="pre">AutoPilot（自动导向）</span></tt>。 自动导向在消息进入检查队列之前启动.
以下代码可以用来转发消息, 例如 <tt class="docutils literal"><span class="pre">A</span> <span class="pre">--&gt;</span> <span class="pre">Probe</span> <span class="pre">--&gt;</span>
<span class="pre">B</span></tt>, 只要满足一定的协约.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">probe</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
<span class="n">probe</span><span class="o">.</span><span class="n">setAutoPilot</span><span class="o">(</span><span class="k">new</span> <span class="nc">TestActor</span><span class="o">.</span><span class="nc">AutoPilot</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">sender</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">TestActor.AutoPilot</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">msg</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="s">&quot;stop&quot;</span> <span class="k">⇒</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="n">x</span>      <span class="k">⇒</span> <span class="n">testActor</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">sender</span><span class="o">);</span> <span class="nc">Some</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">})</span>
</pre></div>
</div>
<p> <tt class="xref py py-meth docutils literal"><span class="pre">run</span></tt> 方法必须返回包含在<tt class="xref py py-class docutils literal"><span class="pre">Option</span></tt>
    中的auto-pilot供下一条消息使用, 设置成 <tt class="xref py py-obj xref docutils literal"><span class="pre">None</span></tt> 表示终止自动导向.</p>
</div>
<div class="section" id="caution-about-timing-assertions">
<h4>小心定时器断言</h4>
<p>在使用测试探针时，<tt class="xref py py-meth docutils literal"><span class="pre">within</span></tt> 块的行为可能会不那么直观：你需要记住 <a class="reference internal" href="#testkit-within"><em>上文</em></a> 所描述的期限仅对每一个探针的局部作用域有效。因此，探针
    不会响应别的探针的期限，也不响应包含它的<tt class="xref py py-class docutils literal"><span class="pre">TestKit</span></tt> 实例的期限:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SomeTest</span> <span class="k">extends</span> <span class="nc">TestKit</span><span class="o">(</span><span class="nc">_system</span><span class="k">:</span> <span class="kt">ActorSystem</span><span class="o">)</span> <span class="k">with</span> <span class="nc">ImplicitSender</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">probe</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>

  <span class="n">within</span><span class="o">(</span><span class="mi">100</span> <span class="n">millis</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">probe</span><span class="o">.</span><span class="n">expectMsg</span><span class="o">(</span><span class="s">&quot;hallo&quot;</span><span class="o">)</span>  <span class="c1">// 将永远挂起!</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>这个测试将无限挂起，因为 <tt class="xref py py-meth docutils literal"><span class="pre">expectMsg</span></tt> 调用看不到任何期限.
    目前，使它正常工作的唯一方法是在代码中使用 <tt class="docutils literal"><span class="pre">probe.within</span></tt> ;
    以后的版本可能会提供通过词法作用域内的隐式参数设置期限的方法.</p>
</div>
</div>
</div>
<div class="section" id="callingthreaddispatcher">
<h2>CallingThreadDispatcher</h2>
<p>如上文所述， <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt> 在单元测试中非常重要,
    但最初它出现是为了在出错的时候能够生成连续的stacktrace. 由于这个特殊的派发器将任何消息直接运行在当前线程中，所以消息处理的完整历史信息在调用堆栈上
    有记录，只要所有的actor都是在这个派发器上运行。</p>
<div class="section" id="how-to-use-it">
<h3>如何使用它</h3>
<p>只要象平常一样设置派发器:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.testkit.CallingThreadDispatcher</span>
<span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">].</span><span class="n">withDispatcher</span><span class="o">(</span><span class="nc">CallingThreadDispatcher</span><span class="o">.</span><span class="nc">Id</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="how-it-works">
<h3>它是如何运作的</h3>
<p>在被调用时,  <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>
    会检查接收消息的actor是否已经在当前线程中了. 这种情况的最简单的例子是actor向自己发送消息. 这时，不能马上对它进行处理，因为这违背了actor模型,
    于是这个消息被放进队列，直到actor的当前消息被处理完毕；这样，新消息会被在调用的线程上处理，只是在actor完成其先前的工作之后.
    在别的情况下，消息会在当前线程中立即得到处理. 通过这个派发器规划的Future也会立即执行.</p>
<p>这种工作方式使 <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>
    象一个为永远不会因为外部事件而阻塞的actor设计的通用派发器.</p>
<p>在有多个线程的情况下，有可能同时有两个使用这个派发器的actor在不同线程中收到消息，它们会竞争actor锁，竞争失败的那个必须等待。
    这样我们保持了actor模型，但由于使用了受限的调度我们损失了一些并发性。从这个意义上说，它等同于使用传统的基于互斥的并发.</p>
<p>另一个困难是正确地处理挂起和继续: 当actor被挂起时，后续的消息将被放进一个thread-local的队列中（和正常情况下使用的队列是同一个). 但是对
<tt class="xref py py-meth docutils literal"><span class="pre">resume</span></tt>的调用, 是由一个特定的线程执行的，系统中所有其它的线程
    可能并没有运行这个特定的actor，这会导致thread-local队列无法被它们的本地线程清空。于是，调用 <tt class="xref py py-meth docutils literal"><span class="pre">resume</span></tt>
    的线程会从所有线程收集所有当前在队列中的消息到自己的队列中，然后进行处理.</p>
</div>
<div class="section" id="limitations">
<h3>局限性</h3>
<p>如果一个actor发送完消息后由于某种原因（通常是被调用actor所影响）阻塞了, 如果使用这个派发器时显然将导致死锁。 这在使用
基于 <tt class="xref py py-class docutils literal"><span class="pre">CountDownLatch</span></tt> 同步的actor测试中很常见:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">latch</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CountDownLatch</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">actor</span> <span class="o">!</span> <span class="n">startWorkAfter</span><span class="o">(</span><span class="n">latch</span><span class="o">)</span>   <span class="c1">// actor 将在开始处理之前调用 latch.await() </span>
<span class="n">doSomeSetupStuff</span><span class="o">()</span>
<span class="n">latch</span><span class="o">.</span><span class="n">countDown</span><span class="o">()</span>
</pre></div>
</div>
<p>这个例子将无限挂起，消息处理到达第二行永远到不了第四行，而只有在第四行才能在一个普通的派发器上取消它的阻塞.</p>
<p>所以要记住 <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt> 并不是普通派发器的
通用替代品. 而另一方面在它上面运行你的actor网络测试会非常有用, 因为如果它在机率特别高的条件下都能不死锁，那么在生产环境中也不会.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">上面这句话很遗憾并不是一个有力的保证，因为你的代码运行在不同的派发器上时可能直接或间接地改变它的行为。
    如果你想要寻找帮助你debug死锁的工具,  <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt> 在有些错误场合下
    可能会有用，但要记住它既可能给出错误的正面结果也可能给出错误的负面结果.</p>
</div>
</div>
<div class="section" id="benefits">
<h3>好处</h3>
<p>综上所述，以下是 <tt class="xref py py-class docutils literal"><span class="pre">CallingThreadDispatcher</span></tt>能够提供的功能:</p>
<blockquote>
<div><ul class="simple">
<li>确定地执行单线程测试，同时保持几乎所有的actor语义</li>
<li>在异常stacktrace中记录从失败点开始的完整的消息处理历史</li>
<li>排除某些类型的死锁场景</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="tracing-actor-invocations">
<span id="actor-logging"></span><h2>跟踪Actor调用</h2>
<p>到目前为止所有的测试工具都针对系统的行为构造断言. 当测试失败时，通常是由你来查找原因，进行修改并进行下一轮测试。这个过程既有debugger支持，又有日志支持，又Akka工具箱提供以下日志选项:</p>
<ul>
<li><p class="first"><em>对Actor实例中抛出的异常记录日志</em></p>
<p>相比其它的日志机制，这一条是永远打开的；它的日志级别是
<tt class="docutils literal"><span class="pre">ERROR</span></tt>.</p>
</li>
<li><p class="first"><em>对某些actor的消息记录日志</em></p>
<p>这是通过在<a class="reference internal" href="../general/configuration.html#configuration" tppabs="http://www.gtan.com/akka_doc/general/configuration.html#configuration"><em>配置文件</em></a>里添加设置项来打开 — 设置项为
<tt class="docutils literal"><span class="pre">akka.actor.debug.receive</span></tt> — 它使得
    <tt class="xref py py-meth docutils literal"><span class="pre">loggable</span></tt>语句作用于actor的 <tt class="xref py py-meth docutils literal"><span class="pre">receive</span></tt> 函数:</p>
</li>
</ul>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.event.LoggingReceive</span>
<span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="nc">LoggingReceive</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">msg</span> <span class="k">⇒</span> <span class="c1">// Do something...</span>
<span class="o">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>.</dt>
<dd><p class="first">如果在 <a class="reference internal" href="../general/configuration.html#configuration" tppabs="http://www.gtan.com/akka_doc/general/configuration.html#configuration"><em>配置文件</em></a>中没有给出上面的配置,
    这个方法将直接移交给给定的 <tt class="xref py py-class docutils literal"><span class="pre">Receive</span></tt> 函数, 也就是说如果不打开，就没有运行时开销.</p>
<p class="last">这个日志功能是与指定的局部标记绑定的，因为将其应用于所有的actor可能不是你所需要的，
    如果被用于<tt class="xref py py-class docutils literal"><span class="pre">EventHandler</span></tt>监听器它还可能导致无限循环.</p>
</dd>
</dl>
<ul>
<li><p class="first"><em>对特殊的消息记录日志</em></p>
<p>Actor会自动处理某些特殊消息, e.g. <tt class="xref py py-obj docutils literal"><span class="pre">Kill</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">PoisonPill</span></tt>, 等等. 打开对这些消息的跟踪只需要设置
    <tt class="docutils literal"><span class="pre">akka.actor.debug.autoreceive</span></tt>, 这对所有actor都有效.</p>
</li>
<li><p class="first"><em>对actor生命周期记录日志</em></p>
<p>Actor的创建、启动、重启、开始监控、停止监控和终止可以通过打开 <tt class="docutils literal"><span class="pre">akka.actor.debug.lifecycle</span></tt> 来跟踪; 这也是对所有
    actor都有效的.</p>
</li>
</ul>
<p>所有这些日志消息都记录在 <tt class="docutils literal"><span class="pre">DEBUG</span></tt> 级别. 总结一下, 你可以用以下配置打开对actor活动的完整日志:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">akka</span> <span class="o">{</span>
  <span class="n">loglevel</span> <span class="k">=</span> <span class="nc">DEBUG</span>
  <span class="n">actor</span> <span class="o">{</span>
    <span class="n">debug</span> <span class="o">{</span>
      <span class="n">receive</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">autoreceive</span> <span class="k">=</span> <span class="n">on</span>
      <span class="n">lifecycle</span> <span class="k">=</span> <span class="n">on</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="javascript:if(confirm('http://akka.io/docs  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/docs'" tppabs="http://akka.io/docs">Documentation</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/downloads  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/downloads'" tppabs="http://akka.io/downloads">Downloads</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/news  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/news'" tppabs="http://akka.io/news">News</a></li>
      <li><a href="javascript:if(confirm('http://letitcrash.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://letitcrash.com/'" tppabs="http://letitcrash.com/">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="javascript:if(confirm('http://github.com/akka/akka  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://github.com/akka/akka'" tppabs="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="javascript:if(confirm('http://groups.google.com/group/akka-user  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://groups.google.com/group/akka-user'" tppabs="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="javascript:if(confirm('http://www.assembla.com/spaces/akka/tickets  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.assembla.com/spaces/akka/tickets'" tppabs="http://www.assembla.com/spaces/akka/tickets">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="javascript:if(confirm('http://typesafe.com/products/typesafe-subscription  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://typesafe.com/products/typesafe-subscription'" tppabs="http://typesafe.com/products/typesafe-subscription">Commercial Support</a></li>
      <li><a href="javascript:if(confirm('http://akka.io/team  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://akka.io/team'" tppabs="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/watermark.png" tppabs="http://www.gtan.com/akka_doc/_static/watermark.png" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2012 <a href="javascript:if(confirm('http://typesafe.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://typesafe.com/'" tppabs="http://typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Mar 08, 2012
    </p>          
  </div>
</div>
<script type="text/javascript">
  $('#toc').toc();
</script>
  

  </body>
</html>
<!-- Localized -->